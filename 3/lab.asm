;==============================================================================
; Программа для обработки текста:
; - Читает файл, указанный в переменной окружения SRC= (или stdin если не указан)
; - Записывает в файл, указанный в переменной окружения DST=
; - Удаляет лишние пробелы (множественные пробелы заменяет на один)
; - После каждого слова добавляет его длину в формате: "слово длина"
; - Использует буферизованный ввод/вывод для эффективности
;==============================================================================

bits    64

section .data
    ; Размеры буферов
    buf_size equ 10 ; размер буфера чтения
    buffer times buf_size db 0 ; буфер для чтения из файла
    out_buf_size equ 20 ; размер выходного буфера
    output_buffer times out_buf_size db 0 ; буфер для записи в файл
    num_buffer    times 20 db 0           ; буфер для преобразования чисел в строки
    
    ; Строки для поиска переменных окружения
    env_src db 'SRC=',0 ; префикс для поиска исходного файла
    env_dst db 'DST=',0 ; префикс для поиска целевого файла
    tmp     db 0        ; временная переменная

section .bss
    ; Дескрипторы файлов и указатели
    src_fd      resq 1 ; дескриптор исходного файла
    dst_fd      resq 1 ; дескриптор целевого файла
    src_ptr     resq 1 ; указатель на путь исходного файла
    dst_ptr     resq 1 ; указатель на путь целевого файла
    out_buf_pos resq 1 ; текущая позиция в выходном буфере

section .text
    global _start

;==============================================================================
; Главная функция программы
; Алгоритм:
; 1. Разбор переменных окружения для получения путей к файлам
; 2. Открытие исходного и целевого файлов
; 3. Циклическое чтение и обработка данных
; 4. Закрытие файлов и завершение программы
;==============================================================================
_start:
    ;--------------------------------------------------------------------------
    ; Инициализация: получение адреса массива переменных окружения (envp)
    ; Структура стека при запуске программы:
    ; [rsp+0]  = argc (количество аргументов)
    ; [rsp+8]  = argv[0] (имя программы)
    ; [rsp+16] = argv[1] (первый аргумент)
    ; ...
    ; [rsp+8*(argc+1)] = NULL (конец argv)
    ; [rsp+8*(argc+2)] = envp[0] (первая переменная окружения)
    ;--------------------------------------------------------------------------
    mov rax, [rsp]   ; rax = argc (количество аргументов командной строки)
    lea rsi, [rsp+8] ; rsi = указатель на argv[0]
    mov rcx, rax     ; rcx = argc
    shl rcx, 3       ; rcx = argc * 8 (размер каждого указателя argv[i])
    add rsi, rcx     ; rsi = указатель на argv[argc]
    add rsi, 8       ; rsi = указатель на envp[0] (пропускаем NULL после argv)
    mov rbx, rsi     ; rbx = envp[0] (для поиска SRC=)
    mov r12, rsi     ; r12 = envp[0] (сохраняем для поиска DST=)

    ;--------------------------------------------------------------------------
    ; Поиск переменной окружения SRC= в массиве envp
    ; Переменные окружения имеют формат "КЛЮЧ=значение"
    ; Цикл проходит по всем элементам envp до NULL
    ;--------------------------------------------------------------------------
find_src_env:
    mov        rdx, [rbx]     ; rdx = указатель на текущую строку envp[i]
    test       rdx, rdx       ; проверяем, не NULL ли указатель
    jz         src_from_stdin ; если NULL — конец envp, SRC не найден, используем stdin
    mov        rsi, rdx       ; rsi = строка envp[i] для сравнения
    mov        rdi, env_src   ; rdi = "SRC=" (образец для поиска)
    mov        rcx, 4         ; rcx = длина строки "SRC=" (4 символа)
    repe cmpsb                ; сравниваем строки побайтно
    je         found_src      ; если совпадают — нашли SRC=
    add        rbx, 8         ; переходим к следующему элементу envp (8 байт на указатель)
    jmp        find_src_env   ; продолжаем поиск

found_src:
    mov rax,       [rbx]   ; rax = указатель на строку "SRC=путь_к_файлу"
    lea rax,       [rax+4] ; rax = указатель на путь (пропускаем "SRC=")
    mov [src_ptr], rax     ; сохраняем указатель на путь исходного файла
    
    ;--------------------------------------------------------------------------
    ; Открытие исходного файла для чтения
    ; Системный вызов open(filename, flags, mode)
    ;--------------------------------------------------------------------------
    mov     rax,      2         ; sys_open (номер системного вызова)
    mov     rdi,      [src_ptr] ; rdi = путь к файлу
    mov     rsi,      0         ; rsi = O_RDONLY (флаг "только чтение")
    mov     rdx,      0         ; rdx = mode (не используется для существующих файлов)
    syscall                     ; вызов ядра
    cmp     rax,      0         ; проверяем результат (отрицательное значение = ошибка)
    js      _exit               ; если ошибка — завершаем программу
    mov     [src_fd], rax       ; сохраняем дескриптор файла
    jmp     after_src_open      ; переходим к поиску DST=

src_from_stdin:
    ;--------------------------------------------------------------------------
    ; Если SRC= не найден, используем стандартный ввод (stdin)
    ; Дескриптор stdin всегда равен 0
    ;--------------------------------------------------------------------------
    mov qword [src_fd], 0 ; используем stdin (дескриптор 0)

after_src_open:
    ;--------------------------------------------------------------------------
    ; Поиск переменной окружения DST= (аналогично поиску SRC=)
    ; Используем сохраненный указатель на начало envp
    ;--------------------------------------------------------------------------
    mov rbx, r12 ; rbx = envp[0] (восстанавливаем начало массива)
    
find_dst_env:
    mov        rdx, [rbx]   ; rdx = указатель на текущую строку envp[i]
    test       rdx, rdx     ; проверяем на NULL
    jz         _exit        ; если DST не найден — завершаем с ошибкой
    mov        rsi, rdx     ; rsi = строка envp[i]
    mov        rdi, env_dst ; rdi = "DST="
    mov        rcx, 4       ; rcx = длина "DST="
    repe cmpsb              ; сравниваем строки
    je         found_dst    ; если совпадают — нашли DST=
    add        rbx, 8       ; переходим к следующему элементу envp
    jmp        find_dst_env ; продолжаем поиск

found_dst:
    mov rax,       [rbx]   ; rax = указатель на строку "DST=путь_к_файлу"
    lea rax,       [rax+4] ; rax = указатель на путь (пропускаем "DST=")
    mov [dst_ptr], rax     ; сохраняем указатель на путь целевого файла

    ;--------------------------------------------------------------------------
    ; Открытие/создание целевого файла для записи
    ; Флаги: O_WRONLY|O_CREAT|O_TRUNC (577 в восьмеричной системе)
    ; - O_WRONLY: только запись
    ; - O_CREAT: создать файл, если не существует
    ; - O_TRUNC: обрезать файл до нуля, если существует
    ;--------------------------------------------------------------------------
    mov rax,      2         ; sys_open
    mov rdi,      [dst_ptr] ; rdi = путь к целевому файлу
    mov rsi,      577       ; rsi = O_WRONLY|O_CREAT|O_TRUNC
    mov rdx,      0o644     ; rdx = права доступа rw-r--r-- (владелец: чтение+запись, остальные: чтение)
    syscall
    cmp rax,      0         ; проверяем результат
    js  close_src           ; если ошибка — закрываем исходный файл и выходим
    mov [dst_fd], rax       ; сохраняем дескриптор целевого файла

    ;--------------------------------------------------------------------------
    ; Инициализация переменных для обработки
    ;--------------------------------------------------------------------------
    mov qword [out_buf_pos], 0   ; инициализируем позицию в выходном буфере
    xor r15,                 r15 ; r15 = накопленная длина текущего слова
    mov r9,                  0   ; r9 = флаг предыдущего символа (0=не-пробел, 1=пробел)
    ;==========================================================================
    ; ГЛАВНЫЙ ЦИКЛ ОБРАБОТКИ ФАЙЛА
    ; Читает файл блоками, обрабатывает каждый блок и записывает результат
    ;==========================================================================
copy_loop:
    ;--------------------------------------------------------------------------
    ; Чтение очередного блока данных из исходного файла
    ; Системный вызов read(fd, buffer, count)
    ;--------------------------------------------------------------------------
    mov     rax, 0        ; sys_read (номер системного вызова)
    mov     rdi, [src_fd] ; rdi = дескриптор исходного файла
    mov     rsi, buffer   ; rsi = буфер для чтения
    mov     rdx, buf_size ; rdx = максимальное количество байт для чтения
    syscall               ; выполняем системный вызов
    cmp     rax, 0        ; проверяем результат (0 = конец файла, <0 = ошибка)
    jle     close_all     ; если конец файла или ошибка — завершаем обработку
    mov     r8,  rax      ; r8 = фактическое количество прочитанных байт

    ;--------------------------------------------------------------------------
    ; Удаление лишних пробелов и табуляций из прочитанного блока
    ; Функция trim_spaces обрабатывает данные "на месте" в буфере
    ;--------------------------------------------------------------------------
    mov  rbx, buffer ; rbx = адрес начала буфера (входной параметр)
    mov  rdx, r8     ; rdx = длина данных в буфере (входной параметр)
    call trim_spaces ; вызываем функцию удаления лишних пробелов
                      ; на выходе: rdx = новая длина данных после обработки

    ;--------------------------------------------------------------------------
    ; ОБРАБОТКА СЛОВ В ТЕКУЩЕМ БЛОКЕ
    ; Алгоритм:
    ; 1. Сканируем буфер, находим слова (последовательности не-разделителей)
    ; 2. Для каждого найденного слова записываем: "слово длина"
    ; 3. Обрабатываем переносы строк и накапливаем длину слов на границах блоков
    ;--------------------------------------------------------------------------
    mov rsi, buffer ; rsi = указатель на начало обработанного буфера
    mov rcx, rdx    ; rcx = длина данных в буфере после trim_spaces
    xor rbx, rbx    ; rbx = текущий индекс (позиция) в буфере

.process_words:
    ;--------------------------------------------------------------------------
    ; Проверка на достижение конца буфера
    ;--------------------------------------------------------------------------
    cmp rbx, rcx   ; сравниваем текущую позицию с длиной буфера
    jge .end_words ; если достигли конца — переходим к следующему блоку

    ;--------------------------------------------------------------------------
    ; Обработка начала блока: проверка на необходимость вывода длины слова
    ; Это нужно для слов, которые начались в предыдущем блоке
    ;--------------------------------------------------------------------------
    xor r14, r14 ; r14 = флаг новой строки (0=обычный режим, 1=после новой строки)

    test rbx,       rbx ; проверяем, находимся ли в начале буфера
    jnz  .next          ; если не в начале — пропускаем специальную обработку
    cmp  byte[rsi], ' ' ; проверяем первый символ блока
    je   .next1         ; если пробел — переходим к обработке
    
    cmp byte[rsi], 10 ; проверяем на символ новой строки (ASCII 10)
    jne .next         ; если не новая строка — продолжаем обычную обработку
    
    mov r14, 1 ; устанавливаем флаг новой строки
    
.next1:
    ;--------------------------------------------------------------------------
    ; Если есть накопленная длина слова из предыдущего блока — выводим её
    ;--------------------------------------------------------------------------
    test r15, r15 ; проверяем, есть ли накопленная длина слова
    je   .next    ; если нет — переходим к обработке текущего блока

    ; Сохраняем регистры перед вызовом функций записи
    push rsi
    push rcx

    ; Записываем разделитель перед длиной слова
    mov  al, ' '           ; al = символ пробела
    call buffer_write_byte ; записываем пробел в выходной буфер

    ; Преобразуем накопленную длину слова в строку и записываем
    mov  edi, r15d        ; edi = накопленная длина слова (32-битное значение)
    call print_int_to_buf ; преобразуем число в строку
                              ; возвращает: r11 = длина строки, rsi = указатель на строку
    mov  rdx, r11     ; rdx = длина строки с числом
    call buffer_write ; записываем строку с длиной в выходной буфер

    ; Если не начало новой строки — добавляем пробел после числа
    test r14, r14 ; проверяем флаг новой строки
    jnz  .m2      ; если новая строка — пропускаем пробел

    mov  al, ' '           ; al = символ пробела
    call buffer_write_byte ; записываем пробел после числа
.m2:
    ; Восстанавливаем регистры
    pop rcx
    pop rsi

    xor r15, r15 ; сбрасываем накопленную длину слова


.next:
    ;--------------------------------------------------------------------------
    ; ПОИСК НАЧАЛА СЛЕДУЮЩЕГО СЛОВА
    ; Пропускаем все разделители (пробелы и переносы строк)
    ;--------------------------------------------------------------------------
.skip_nonword:
    cmp rbx, rcx          ; проверяем, не достигли ли конца буфера
    jge .end_words        ; если достигли — завершаем обработку блока
    mov al,  [rsi + rbx]  ; al = текущий символ
    cmp al,  ' '          ; сравниваем с пробелом
    je  .inc_bx           ; если пробел — пропускаем его
    cmp al,  10           ; сравниваем с символом новой строки
    je  .inc_nl           ; если новая строка — обрабатываем специально
    jmp .word_start_found ; если не разделитель — нашли начало слова

.inc_nl:
    ;--------------------------------------------------------------------------
    ; Обработка символа новой строки
    ; Записываем его в выходной буфер для сохранения форматирования
    ;--------------------------------------------------------------------------
    mov  al, 10            ; al = символ новой строки
    call buffer_write_byte ; записываем новую строку в выходной буфер

.inc_bx:
    inc rbx           ; переходим к следующему символу
    jmp .skip_nonword ; продолжаем пропускать разделители

.word_start_found:
    ;--------------------------------------------------------------------------
    ; НАЙДЕНО НАЧАЛО СЛОВА
    ; Сохраняем позицию начала и ищем конец слова
    ;--------------------------------------------------------------------------
    mov r8, rbx ; r8 = индекс начала текущего слова

.find_word_end:
    ;--------------------------------------------------------------------------
    ; Поиск конца слова (до разделителя или конца буфера)
    ;--------------------------------------------------------------------------
    cmp rbx, rcx         ; проверяем, не достигли ли конца буфера
    jge .copy_word_end   ; если достигли — слово продолжается в следующем блоке
    mov al,  [rsi + rbx] ; al = текущий символ
    cmp al,  ' '         ; сравниваем с пробелом
    je  .copy_word       ; если пробел — найден полный конец слова
    cmp al,  10          ; сравниваем с новой строкой
    je  .copy_word       ; если новая строка — найден полный конец слова
    inc rbx              ; переходим к следующему символу слова
    jmp .find_word_end   ; продолжаем поиск конца слова

.copy_word_end:
    ;--------------------------------------------------------------------------
    ; ОБРАБОТКА НЕПОЛНОГО СЛОВА (продолжается в следующем блоке)
    ; Записываем найденную часть слова и накапливаем её длину
    ;--------------------------------------------------------------------------
    mov r10, rbx ; r10 = индекс конца слова в текущем блоке
    sub r10, r8  ; r10 = длина части слова в текущем блоке

    ; Сохраняем регистры перед вызовом функции записи
    push rsi
    
    lea  rsi, [buffer + r8] ; rsi = указатель на начало части слова
    mov  rdx, r10           ; rdx = длина части слова
    push rcx                ; сохраняем длину буфера
    call buffer_write       ; записываем часть слова в выходной буфер
    pop  rcx                ; восстанавливаем длину буфера
    pop  rsi                ; восстанавливаем указатель на буфер
    
    add r15, r10   ; накапливаем общую длину слова
    jmp .end_words ; переходим к обработке следующего блока
.copy_word:
    ;--------------------------------------------------------------------------
    ; ОБРАБОТКА ПОЛНОГО СЛОВА (заканчивается в текущем блоке)
    ; Записываем слово, пробел и его длину
    ;--------------------------------------------------------------------------
    mov r10, rbx ; r10 = индекс конца слова
    sub r10, r8  ; r10 = длина слова в текущем блоке

    ; Сохраняем регистры перед вызовами функций
    push rsi
    push rcx
    
    ; Записываем само слово
    lea  rsi, [buffer + r8] ; rsi = указатель на начало слова
    mov  rdx, r10           ; rdx = длина слова
    call buffer_write       ; записываем слово в выходной буфер

    ; Записываем разделитель после слова
    mov  al, ' '           ; al = символ пробела
    call buffer_write_byte ; записываем пробел после слова

    ; Вычисляем общую длину слова (включая накопленную из предыдущих блоков)
    add r10, r15 ; r10 = общая длина слова
    
    ; Преобразуем длину слова в строку и записываем
    mov  edi, r10d        ; edi = общая длина слова
    call print_int_to_buf ; преобразуем число в строку
                              ; возвращает: r11 = длина строки, rsi = указатель на строку
    mov  rdx, r11     ; rdx = длина строки с числом
    call buffer_write ; записываем длину слова в выходной буфер

    ; Восстанавливаем регистры
    pop rcx
    pop rsi

    ;--------------------------------------------------------------------------
    ; Проверка необходимости добавления пробела после числа
    ; Пробел не нужен, если следующий символ — новая строка
    ;--------------------------------------------------------------------------
    cmp byte[rsi + rbx], 10 ; проверяем текущий символ (разделитель после слова)
    je  .m3                 ; если новая строка — пропускаем пробел

    cmp byte[rsi + rbx + 1], 10 ; проверяем следующий символ
    je  .m3                     ; если следующий символ — новая строка, пропускаем пробел

    ; Добавляем пробел после числа
    push rsi
    push rcx

    mov  al, ' '           ; al = символ пробела
    call buffer_write_byte ; записываем пробел после числа
    
    pop rcx
    pop rsi

.m3:   
    xor r15, r15       ; сбрасываем накопленную длину слова
    jmp .process_words ; продолжаем обработку следующих слов

.end_words:
    ;--------------------------------------------------------------------------
    ; Завершение обработки текущего блока
    ; Переходим к чтению и обработке следующего блока данных
    ;--------------------------------------------------------------------------
    jmp copy_loop ; возвращаемся к чтению следующего блока

    ;==========================================================================
    ; ЗАВЕРШЕНИЕ ПРОГРАММЫ И ОСВОБОЖДЕНИЕ РЕСУРСОВ
    ;==========================================================================
close_all:
    ;--------------------------------------------------------------------------
    ; Завершение обработки: сброс буферов и закрытие файлов
    ;--------------------------------------------------------------------------
    call flush_output_buffer ; записываем остатки данных из выходного буфера в файл
    
    ; Закрытие целевого файла
    mov     rax, 3        ; sys_close (номер системного вызова)
    mov     rdi, [dst_fd] ; rdi = дескриптор целевого файла
    syscall               ; закрываем файл

close_src:
    ;--------------------------------------------------------------------------
    ; Закрытие исходного файла
    ;--------------------------------------------------------------------------
    mov     rax, 3        ; sys_close
    mov     rdi, [src_fd] ; rdi = дескриптор исходного файла
    syscall               ; закрываем файл

_exit:
    ;--------------------------------------------------------------------------
    ; Завершение программы с кодом возврата 0 (успех)
    ;--------------------------------------------------------------------------
    mov     rax, 60  ; sys_exit (номер системного вызова)
    xor     rdi, rdi ; rdi = 0 (код возврата: успех)
    syscall          ; завершаем программу

;==============================================================================
; ФУНКЦИЯ УДАЛЕНИЯ ЛИШНИХ ПРОБЕЛОВ И ТАБУЛЯЦИЙ
; Входные параметры:
;   rbx = указатель на буфер с данными
;   rdx = длина данных в буфере
; Выходные параметры:
;   rdx = новая длина данных после обработки
; 
; Алгоритм:
; 1. Заменяет табуляции на пробелы
; 2. Удаляет множественные пробелы (заменяет на один)
; 3. Удаляет пробелы в начале строк (после символов новой строки)
; 4. Удаляет пробелы в конце буфера
; 
; Использует глобальную переменную r9 для отслеживания состояния:
; r9 = 0 : предыдущий символ не был пробелом
; r9 = 1 : предыдущий символ был пробелом
;==============================================================================
trim_spaces:
    ; Сохранение регистров на стеке
    push rbx
    push rsi
    push rdi
    push rcx
    push rax

    mov rsi, rbx ; rsi = указатель на источник (чтение)
    mov rdi, rbx ; rdi = указатель на назначение (запись)
    xor rcx, rcx ; rcx = индекс текущего символа в источнике
    xor rax, rax ; rax = текущий обрабатываемый символ

.loop:
    ;--------------------------------------------------------------------------
    ; Основной цикл обработки символов
    ;--------------------------------------------------------------------------
    cmp rcx, rdx         ; проверяем, обработали ли все символы
    jge .end_loop        ; если да — переходим к финальной обработке
    mov al,  [rsi + rcx] ; загружаем текущий символ

    ;--------------------------------------------------------------------------
    ; Обработка символа новой строки
    ;--------------------------------------------------------------------------
    cmp al, 10          ; проверяем на символ новой строки ('\n')
    je  .handle_newline ; если новая строка — специальная обработка

    ;--------------------------------------------------------------------------
    ; Обработка пробелов и табуляций
    ;--------------------------------------------------------------------------
    cmp al, ' '     ; проверяем на пробел
    je  .not_space2 ; если пробел — переходим к обработке пробелов

    cmp al, 9      ; проверяем на табуляцию (ASCII 9)
    jne .not_space ; если не табуляция — это обычный символ
    mov al, ' '    ; заменяем табуляцию на пробел
    
.not_space2:
    ;--------------------------------------------------------------------------
    ; Логика удаления множественных пробелов
    ;--------------------------------------------------------------------------
    cmp r9,    1   ; проверяем, был ли предыдущий символ пробелом
    je  .skip_copy ; если да — пропускаем текущий пробел
    mov r9,    1   ; устанавливаем флаг "предыдущий символ = пробел"
    mov [rdi], al  ; записываем пробел в выходной буфер
    inc rdi        ; переходим к следующей позиции записи
    jmp .next      ; переходим к следующему символу

.handle_newline:
    ;--------------------------------------------------------------------------
    ; Обработка новой строки: копируем её и пропускаем пробелы после неё
    ;--------------------------------------------------------------------------
    mov [rdi], al ; записываем символ новой строки
    inc rdi       ; переходим к следующей позиции записи
    mov r9,    0  ; сбрасываем флаг пробела (новая строка сбрасывает состояние)

.skip_after_newline:
    ;--------------------------------------------------------------------------
    ; Пропуск пробелов и табуляций в начале новой строки
    ;--------------------------------------------------------------------------
    inc rcx                 ; переходим к следующему символу
    cmp rcx, rdx            ; проверяем, не достигли ли конца буфера
    jge .end_loop           ; если достигли — завершаем обработку
    mov al,  [rsi + rcx]    ; загружаем следующий символ
    cmp al,  ' '            ; проверяем на пробел
    je  .skip_after_newline ; если пробел — пропускаем его
    cmp al,  9              ; проверяем на табуляцию
    je  .skip_after_newline ; если табуляция — пропускаем её
    dec rcx                 ; возвращаемся назад, чтобы обработать не-пробельный символ
    jmp .next               ; переходим к следующей итерации

.not_space:
    ;--------------------------------------------------------------------------
    ; Обработка обычного символа (не пробел, не табуляция, не новая строка)
    ;--------------------------------------------------------------------------
    mov r9,    0  ; сбрасываем флаг пробела
    mov [rdi], al ; записываем символ в выходной буфер
    inc rdi       ; переходим к следующей позиции записи

.skip_copy:
.next:
    inc rcx   ; переходим к следующему символу источника
    jmp .loop ; продолжаем основной цикл

.end_loop:
    ;--------------------------------------------------------------------------
    ; Удаление пробелов и табуляций в конце буфера
    ; Это необходимо для корректной обработки файлов, заканчивающихся пробелами
    ;--------------------------------------------------------------------------
    cmp rdi,        rbx     ; проверяем, есть ли данные в выходном буфере
    je  .no_trailing        ; если буфер пустой — пропускаем удаление
    dec rdi                 ; переходим к последнему записанному символу
    cmp byte [rdi], ' '     ; проверяем, является ли он пробелом
    je  .trim_trailing_loop ; если да — начинаем удаление завершающих пробелов
    cmp byte [rdi], 9       ; проверяем на табуляцию
    jne .no_trailing_inc    ; если не пробел и не табуляция — завершаем

.trim_trailing_loop:
    ;--------------------------------------------------------------------------
    ; Цикл удаления завершающих пробелов и табуляций
    ;--------------------------------------------------------------------------
    cmp rdi,        rbx ; проверяем, не дошли ли до начала буфера
    jl  .trim_done      ; если дошли — завершаем удаление
    cmp byte [rdi], ' ' ; проверяем текущий символ на пробел
    je  .m1             ; если пробел — удаляем его
    cmp byte [rdi], 9   ; проверяем на табуляцию
    jne .trim_done      ; если не пробел и не табуляция — завершаем удаление
.m1:
    dec rdi                 ; переходим к предыдущему символу
    jmp .trim_trailing_loop ; продолжаем удаление

.trim_done:
    inc rdi ; корректируем указатель (он указывает на символ перед концом)

.no_trailing_inc:
    inc rdi ; устанавливаем указатель на позицию после последнего символа

.no_trailing:
    ;--------------------------------------------------------------------------
    ; Вычисление новой длины буфера и восстановление регистров
    ;--------------------------------------------------------------------------
    mov rdx, rdi ; rdx = указатель на конец данных
    sub rdx, rbx ; rdx = новая длина данных (конец - начало)

    ; Восстановление сохраненных регистров
    pop rax
    pop rcx
    pop rdi
    pop rsi
    pop rbx
    ret     ; возврат из функции


;==============================================================================
; ФУНКЦИЯ БУФЕРИЗОВАННОЙ ЗАПИСИ ДАННЫХ
; Входные параметры:
;   rsi = указатель на данные для записи
;   rdx = количество байт для записи
; 
; Функция копирует данные в выходной буфер. Если буфер заполняется,
; автоматически сбрасывает его содержимое в файл и продолжает запись.
; Это повышает эффективность за счет уменьшения количества системных вызовов.
;==============================================================================
buffer_write:
    ; Сохранение регистров
    push rax
    push rcx
    push rdi
    push rsi
    push rdx

    mov rdi, [out_buf_pos] ; rdi = текущая позиция в выходном буфере
    
.write_loop:
    ;--------------------------------------------------------------------------
    ; Основной цикл копирования данных в буфер
    ;--------------------------------------------------------------------------
    test rdx, rdx    ; проверяем, остались ли данные для записи
    jz   .write_done ; если нет — завершаем функцию
    
    ; Проверка свободного места в буфере
    cmp rdi, out_buf_size   ; сравниваем текущую позицию с размером буфера
    jge .flush_and_continue ; если буфер заполнен — сбрасываем его
    
    ; Копирование одного байта в буфер
    mov al,                    [rsi] ; загружаем байт из источника
    mov [output_buffer + rdi], al    ; записываем в выходной буфер
    inc rsi                          ; переходим к следующему байту источника
    inc rdi                          ; переходим к следующей позиции в буфере
    dec rdx                          ; уменьшаем счетчик оставшихся байт
    jmp .write_loop                  ; продолжаем копирование
    
.flush_and_continue:
    ;--------------------------------------------------------------------------
    ; Сброс заполненного буфера в файл и продолжение записи
    ;--------------------------------------------------------------------------
    mov  [out_buf_pos], rdi           ; сохраняем текущую позицию
    push rsi                          ; сохраняем указатель на данные
    push rdx                          ; сохраняем счетчик байт
    call flush_output_buffer          ; сбрасываем буфер в файл
    pop  rdx                          ; восстанавливаем счетчик байт
    pop  rsi                          ; восстанавливаем указатель на данные
    mov  rdi,           [out_buf_pos] ; rdi должно быть 0 после сброса буфера
    jmp  .write_loop                  ; продолжаем копирование
    
.write_done:
    ;--------------------------------------------------------------------------
    ; Завершение записи: сохранение позиции и восстановление регистров
    ;--------------------------------------------------------------------------
    mov [out_buf_pos], rdi ; сохраняем финальную позицию в буфере
    
    ; Восстановление регистров
    pop rdx
    pop rsi
    pop rdi
    pop rcx
    pop rax
    ret

;==============================================================================
; ФУНКЦИЯ ЗАПИСИ ОДНОГО БАЙТА В ВЫХОДНОЙ БУФЕР
; Входные параметры:
;   al = байт для записи
; 
; Функция добавляет один байт в выходной буфер. Если буфер заполнен,
; автоматически сбрасывает его в файл перед записью нового байта.
;==============================================================================
buffer_write_byte:
    ; Сохранение регистров
    push rax
    push rdi
    
    mov rdi, [out_buf_pos] ; rdi = текущая позиция в буфере
    
    ; Проверка свободного места в буфере
    cmp rdi, out_buf_size ; сравниваем позицию с размером буфера
    jge .flush_first      ; если буфер заполнен — сначала сбрасываем его
    
    ; Запись байта в буфер
    mov [output_buffer + rdi], al  ; записываем байт в текущую позицию
    inc rdi                        ; увеличиваем позицию
    mov [out_buf_pos],         rdi ; сохраняем новую позицию
    jmp .done                      ; завершаем функцию
    
.flush_first:
    ;--------------------------------------------------------------------------
    ; Сброс заполненного буфера перед записью нового байта
    ;--------------------------------------------------------------------------
    push rax                                  ; сохраняем байт для записи
    call flush_output_buffer                  ; сбрасываем буфер в файл
    pop  rax                                  ; восстанавливаем байт
    mov  rdi,                   [out_buf_pos] ; получаем новую позицию (должна быть 0)
    mov  [output_buffer + rdi], al            ; записываем байт
    inc  rdi                                  ; увеличиваем позицию
    mov  [out_buf_pos],         rdi           ; сохраняем позицию
    
.done:
    ; Восстановление регистров
    pop rdi
    pop rax
    ret

;==============================================================================
; ФУНКЦИЯ СБРОСА ВЫХОДНОГО БУФЕРА В ФАЙЛ
; 
; Записывает все накопленные в выходном буфере данные в целевой файл
; и сбрасывает позицию буфера в ноль. Эта функция вызывается автоматически
; при заполнении буфера или в конце программы для записи остатков данных.
;==============================================================================
flush_output_buffer:
    ; Сохранение регистров
    push rax
    push rdi
    push rsi
    push rdx
    
    mov  rdx, [out_buf_pos] ; rdx = количество байт в буфере для записи
    test rdx, rdx           ; проверяем, есть ли данные в буфере
    jz   .nothing_to_flush  ; если буфер пустой — ничего не делаем
    
    ;--------------------------------------------------------------------------
    ; Системный вызов записи буфера в файл
    ;--------------------------------------------------------------------------
    mov     rax, 1             ; sys_write (номер системного вызова)
    mov     rdi, [dst_fd]      ; rdi = дескриптор целевого файла
    mov     rsi, output_buffer ; rsi = указатель на данные для записи
    syscall                    ; выполняем запись в файл
    
    mov qword [out_buf_pos], 0 ; сбрасываем позицию буфера в ноль
    
.nothing_to_flush:
    ; Восстановление регистров
    pop rdx
    pop rsi
    pop rdi
    pop rax
    ret


;==============================================================================
; ФУНКЦИЯ ПРЕОБРАЗОВАНИЯ ЦЕЛОГО ЧИСЛА В СТРОКУ
; Входные параметры:
;   edi = число для преобразования (32-битное беззнаковое)
; Выходные параметры:
;   r11 = длина полученной строки
;   rsi = указатель на начало строки с числом
; 
; Функция преобразует число в десятичную строку, используя алгоритм
; деления на 10 и записи остатков справа налево в буфер num_buffer.
; Результирующая строка НЕ завершается нулевым символом.
;==============================================================================
print_int_to_buf:
    ; Сохранение регистров
    push rax
    push rcx
    push rdx
    push rdi
    push rbx

    ;--------------------------------------------------------------------------
    ; Инициализация: подготовка буфера и переменных
    ;--------------------------------------------------------------------------
    mov eax,        edi             ; eax = число для преобразования
    mov rdi,        num_buffer + 19 ; rdi = указатель на конец буфера (20-й байт)
    mov byte [rdi], 0               ; записываем завершающий ноль (для отладки)
    dec rdi                         ; rdi = указатель на последнюю позицию для цифры
    
    mov ecx, 10  ; ecx = основание системы счисления (десятичная)
    xor rbx, rbx ; rbx = счетчик цифр в числе

.print_digit:
    ;--------------------------------------------------------------------------
    ; Основной цикл: извлечение цифр числа справа налево
    ; Алгоритм: повторно делим число на 10, остаток = очередная цифра
    ;--------------------------------------------------------------------------
    xor edx, edx ; обнуляем edx перед делением
    div ecx      ; eax = частное, edx = остаток (цифра)

    add edx,   '0' ; преобразуем цифру в ASCII-символ
    mov [rdi], dl  ; записываем символ в буфер
    dec rdi        ; переходим к предыдущей позиции
    inc rbx        ; увеличиваем счетчик цифр
    
    test eax, eax     ; проверяем, остались ли цифры
    jnz  .print_digit ; если да — продолжаем извлечение

    ;--------------------------------------------------------------------------
    ; Завершение: установка указателей для возврата результата
    ;--------------------------------------------------------------------------
    inc rdi      ; rdi теперь указывает на начало числа
    mov rsi, rdi ; rsi = указатель на начало строки (возвращаемое значение)
    mov r11, rbx ; r11 = длина строки (возвращаемое значение)

    ; Восстановление регистров
    pop rbx
    pop rdi
    pop rdx
    pop rcx
    pop rax
    ret
